// Generated by LiveScript 1.3.1
var slice$ = [].slice;
(function(){
  var loadFile, ldFile, this$ = this;
  loadFile = function(f, t, e){
    t == null && (t = 'binary');
    return new Promise(function(res, rej){
      var fr;
      fr = new FileReader();
      fr.onload = function(){
        return res({
          result: fr.result,
          file: f
        });
      };
      if (t === 'dataurl') {
        return fr.readAsDataURL(f);
      } else if (t === 'text') {
        return fr.readAsText(f, e || 'utf-8');
      } else if (t === 'binary') {
        return fr.readAsBinaryString(f);
      } else if (t === 'arraybuffer' || t === 'blob') {
        return fr.readAsArrayBuffer(f);
      } else if (t === 'blob') {
        return res(f);
      } else if (t === 'bloburl') {
        return res(URL.createObjectURL(f));
      } else {
        return rej(new Error("ldFile: un-supported type"));
      }
    });
  };
  ldFile = function(opt){
    var root, fromPrompt, this$ = this;
    opt == null && (opt = {});
    import$(this, {
      evtHandler: {},
      opt: opt,
      root: root = typeof opt.root === 'string'
        ? document.querySelector(opt.root)
        : opt.root,
      type: opt.type || 'binary',
      ldcv: opt.ldcv || null,
      encoding: opt.forceEncoding
    });
    fromPrompt = function(){
      return new Promise(function(res, rej){
        var ret;
        return res(ret = prompt("encoding:", "utf-8"));
      });
    };
    this.root.addEventListener('change', function(e){
      var files, promise;
      files = e.target.files;
      if (!files.length) {
        return;
      }
      promise = this$.type === 'text' && !opt.forceEncoding
        ? (this$.ldcv
          ? this$.ldcv.get()
          : fromPrompt()).then(function(it){
          return this$.encoding = it;
        })
        : Promise.resolve();
      return promise.then(function(){
        return Promise.all(Array.from(files).map(function(f){
          return loadFile(f, this$.type, this$.encoding);
        }));
      }).then(function(it){
        return this$.fire('load', it);
      });
    });
    return this;
  };
  ldFile.prototype = import$(Object.create(Object.prototype), {
    on: function(n, cb){
      var ref$;
      return ((ref$ = this.evtHandler)[n] || (ref$[n] = [])).push(cb);
    },
    fire: function(n){
      var v, i$, ref$, len$, cb, results$ = [];
      v = slice$.call(arguments, 1);
      for (i$ = 0, len$ = (ref$ = this.evtHandler[n] || []).length; i$ < len$; ++i$) {
        cb = ref$[i$];
        results$.push(cb.apply(this, v));
      }
      return results$;
    }
  });
  import$(ldFile, {
    fromURL: function(u, t, e){
      return new Promise(function(res, rej){
        var r;
        r = new XMLHttpRequest();
        r.open('GET', u, true);
        r.responseType = 'blob';
        r.onload = function(){
          return loadFile(r.response, t, e).then(res)['catch'](rej);
        };
        return r.send();
      });
    },
    fromFile: function(f, t, e){
      return loadFile(f, t, e);
    }
  });
  if (typeof module != 'undefined' && module !== null) {
    module.exports = ldFile;
  }
  if (window) {
    return window.ldFile = ldFile;
  }
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
